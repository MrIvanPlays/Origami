From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MrIvanPlays <ivan@mrivanplays.com>
Date: Thu, 16 Jul 2020 14:17:01 +0300
Subject: [PATCH] Build in a packet limiter

The main reasoning behind is that most of the servers suffer due to packet spam which drops the TPS.

diff --git a/src/main/java/com/mrivanplays/origami/util/PacketBucket.java b/src/main/java/com/mrivanplays/origami/util/PacketBucket.java
new file mode 100644
index 0000000000000000000000000000000000000000..c8da2b4a83e3da4a41eb3ff96737764c3fad61cb
--- /dev/null
+++ b/src/main/java/com/mrivanplays/origami/util/PacketBucket.java
@@ -0,0 +1,79 @@
+package com.mrivanplays.origami.util;
+
+import java.util.Arrays;
+
+public class PacketBucket {
+
+    private static final double NANOSECONDS_TO_MILLISECONDS = 1.0e-6; // 1e3 / 1e9
+
+    private static final int MILLISECONDS_TO_SECONDS = 1000;
+    public final double intervalTime;
+    public final double intervalResolution;
+    public final int totalBuckets;
+    private final int[] data;
+    private int newestData;
+    private double lastBucketTime;
+    private int sum;
+
+    public PacketBucket(final double intervalTime, final int totalBuckets) {
+        this.intervalTime = intervalTime;
+        this.intervalResolution = intervalTime/(double)totalBuckets;
+        this.totalBuckets = totalBuckets;
+        this.data = new int[totalBuckets];
+    }
+
+    public int incrementPackets(final int packets) {
+        return this.incrementPackets(System.nanoTime(), packets);
+    }
+
+    private int incrementPackets(final long currentTime, final int packets) {
+        final double timeMs = currentTime * NANOSECONDS_TO_MILLISECONDS;
+        double timeDelta = timeMs - this.lastBucketTime;
+
+        if (timeDelta < 0.0) {
+            timeDelta = 0.0;
+        }
+
+        if (timeDelta < this.intervalResolution) {
+            this.data[this.newestData] += packets;
+            return this.sum += packets;
+        }
+
+        final int bucketsToMove = (int)(timeDelta / this.intervalResolution);
+
+        final double nextBucketTime = this.lastBucketTime + bucketsToMove * this.intervalResolution;
+
+        if (bucketsToMove >= this.totalBuckets) {
+            Arrays.fill(this.data, 0);
+
+            this.data[0] = packets;
+            this.sum = packets;
+            this.newestData = 0;
+            this.lastBucketTime = timeMs;
+
+            return packets;
+        }
+
+        for (int i = 1; i < bucketsToMove; ++i) {
+            final int index = (this.newestData + i) % this.totalBuckets;
+            this.sum -= this.data[index];
+            this.data[index] = 0;
+        }
+
+        final int newestDataIndex = (this.newestData + bucketsToMove) % this.totalBuckets;
+        this.sum += packets - this.data[newestDataIndex]; // this.sum += packets; this.sum -= this.data[index]
+        this.data[newestDataIndex] = packets;
+        this.newestData = newestDataIndex;
+        this.lastBucketTime = nextBucketTime;
+
+        return this.sum;
+    }
+
+    public int getTotalPackets() {
+        return this.sum;
+    }
+
+    public double getCurrentPacketRate() {
+        return this.sum / (this.intervalTime / (double)MILLISECONDS_TO_SECONDS);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PacketDecoder.java b/src/main/java/net/minecraft/server/PacketDecoder.java
index c0afb2a3c282ea7ab8c1d99b80843dc23b9f5252..42d8d9cb1e7525d662aaebd9d943312cc5bf1f66 100644
--- a/src/main/java/net/minecraft/server/PacketDecoder.java
+++ b/src/main/java/net/minecraft/server/PacketDecoder.java
@@ -16,12 +16,26 @@ public class PacketDecoder extends ByteToMessageDecoder {
     private static final Marker b = MarkerManager.getMarker("PACKET_RECEIVED", NetworkManager.b);
     private final EnumProtocolDirection c;
 
+    // Origami start
+    private com.mrivanplays.origami.util.PacketBucket bucket = new com.mrivanplays.origami.util.PacketBucket(7000.0, 150);
+    private boolean handlePacketLimit(ChannelHandlerContext ctx) {
+        int packets = bucket.incrementPackets(1);
+        if (bucket.getCurrentPacketRate() > 500) {
+            ctx.close();
+            LOGGER.log(org.apache.logging.log4j.Level.WARN, "A player was kicked for sending too many packets! {} in the last {} seconds", packets, bucket.intervalTime / 1000.0);
+            return true;
+        }
+        return false;
+    }
+    // Origami end
+
     public PacketDecoder(EnumProtocolDirection enumprotocoldirection) {
         this.c = enumprotocoldirection;
     }
 
     protected void decode(ChannelHandlerContext channelhandlercontext, ByteBuf bytebuf, List<Object> list) throws Exception {
         if (bytebuf.readableBytes() != 0) {
+            if (handlePacketLimit(channelhandlercontext)) { return; } // Origami
             PacketDataSerializer packetdataserializer = new PacketDataSerializer(bytebuf);
             int i = packetdataserializer.i();
             Packet<?> packet = ((EnumProtocol) channelhandlercontext.channel().attr(NetworkManager.c).get()).a(this.c, i);
